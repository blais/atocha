================
  atocha: TODO
================

- Provide examples for:

  * Parsing with user checks
  * Customized rendering

  Examples should also be runnable code, use the same files (maybe with symlinks
  to remove the extensions).

- Convert all my codebase to Atocha.

- Create a mod_python normalizer, and one for draco (my framework).












Future New Field Types
======================

- Complete the SetFileField with some JavaScript to hide the file input field
  when the reset button is checked.

- Implement a CaptchaField which generates a captcha image automatically.

- Maybe derive from FileUpload and implement a Photograph field that reads the
  value entirely and can print it and display it.  That field could also have
  some Javascript to reset that field automatically.

- Implement a BoolField that requires being checked (AgreeField).

- Grab some of the fields from other libraries and adapt.  Also look at widgets
  from FormEncode and see if some of them can be adapted to my framework.

- Implement a menu that redirects on change based on this:
  http://cscie12.dce.harvard.edu/lecture_notes/20050316/slide50.html

- Something to fix eventually: the JSDateField script has hardcoded paths for
  its accompanying images... not sure what to do about this yet. I suppose the
  user has to copy the files anyway, so it might be ok to assume he might edit
  the scripts somewhat.

- General purpose buttons that would be a form in themselves... we need to
  provide some mechanism for easily rendering those rather than to have to
  define an empty form.


Ideas
=====

- Document the types_* where a list is present.  Type assertions should use a
  debugging function that can be noop'ed and that recurses into the lists for
  better type checking and that can be noop'ed for efficiency.  Find a way to do
  that.

- Could our system support fields which have more than one varname?  I think so.
  Would that be useful?  If it does, look into doing this, creating fields which
  are comprised of multiple possibly-heterogeneous input widgets.  For example,
  we could have a date field with three string input widgets.  Implement a date
  field with three input widgets to test the varname list with more than one
  name.

- Consider making the implementation for the form renderer use a delegate rather
  than derivation.  The delegate would be specified as a class attribute on the
  form renderer itself.  This reflects well the fact that the form renderer
  changes, but the styling code contains no if little variable code.

  I'm not sure about this, since the text form renderer already does take an
  option...

- Implement DISABLED and READ-ONLY options for all the fields.

  * Hmmm... a field can be visible/enabled, visible/disabled or hidden.  It
    cannot be hidden/disabled.

  * Also, a field can be rendered disabled, but not actually be disabled
    permanently.  I'm not sure what would be the utility in creating a field as
    disabled.  Disabled is akin to hidden, and as such is more of a rendering
    option than anything else.  IMO we should support disabled similar to
    hidden.

- Support ACCESS-KEYS and TABINDEX for widgets that are not hidden?

- Support general client-side scripting hooks (core events and input events)?
  Can we integrate button input fields for client-side scripting?

- Support images for submit buttons.

- Create builder.cgi builder test script, where you gradually store the form
  contents in the session data, where you can create fields and remove them too.
  Also, simple test with a menu and a list of widget strings to eval would be
  nice and easy.

- Implement a ``ButtonForm`` class that will render a form with a single submit
  button, just to redirect somewhere, no table.


- Implement 'noempty' in the renderers (previous code: it isn't used much apart
  from the profile and cannot be guaranteed to make sense anymore.  We are
  better work around it in the client code.)

  This is actually not quite right: in the display renderer, it does make sense
  to not want to render fields for which there is no value set.  It only makes
  sense for the display-only renderer.  Maybe that renderer could take an option
  in its constructor?


- For the parser: Maybe we could eventually provide a way to at least decode the
  args which have no corresponding field in the form (if that never becomes
  necessary, don't do so).


More Tests
==========

- Automate tests for four cases: hidden, valid, invalid, empty.

