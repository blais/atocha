================
  atocha: TODO
================

Current Affairs (Requirements Before 1.0 Initial Release)
=========================================================

- The display renderer definitely needs an option to not display fields which
  have no value.







- Write more complete usage documentation for Atocha, in LaTeX using the
  standard Python tools.


Known Bugs and Misfeatures
==========================

- The JSDateField does not yet support disabled/read-only states.  We would need
  to change the JavaScript file to support that.

- You need to customize the javascript file when you copy them, to adjust some
  of the paths at the top of the file to point to the appropriate icons that it
  refers.

- We do support accessibility features yet (but we could and we will). See notes
  below.

- We need to support more of the JS tags. - onclick - onchange, etc.  I need
  more time to test them, for now I just put the ones that I needed immediately
  (checkboxes, menus).

- The tests don't run in optimized mode, this is not really a bug, but rather
  just to the assert function that we use in the test.


Future New Field Types Ideas
============================

- Complete the SetFileField with some JavaScript to hide the file input field
  when the reset button is checked.

- Implement a CaptchaField which generates a captcha image automatically.

- Maybe derive from FileUpload and implement a Photograph field that reads the
  value entirely and can print it and display it.  That field could also have
  some Javascript to reset that field automatically.

- Implement a BoolField that requires being checked (AgreeField).

- Grab some of the fields from other libraries and adapt.  Also look at widgets
  from FormEncode and see if some of them can be adapted to my framework.

- Implement a menu that redirects on change based on this:
  http://cscie12.dce.harvard.edu/lecture_notes/20050316/slide50.html

- Something to fix eventually: the JSDateField script has hardcoded paths for
  its accompanying images... not sure what to do about this yet. I suppose the
  user has to copy the files anyway, so it might be ok to assume he might edit
  the scripts somewhat.



Ideas
=====

- Write a simple example of templating library integration, something simple
  that everyone can understand, just replacing div tags with ids by regexps or
  something.

- Document the types_* subtypes where a list is present.  Type assertions should
  use a debugging function that can be noop'ed and that otherwise recurses into
  the lists for better type checking and that can be noop'ed for efficiency.
  Find a way to do that.

- Consider making the implementation for the form renderer use a delegate rather
  than derivation.  The delegate would be specified as a class attribute on the
  form renderer itself.  This reflects well the fact that the form renderer
  changes, but the styling code contains no if little variable code.

  I'm not sure about this, since the text form renderer already does take an
  option...

- Support accessibilityL FIELDSET, LEGEND, LABEL tags for organization.  Deal
  with Access keys, tab index.  This should be a simple matter of supporting
  adding attributes and then making the renderers support them.  Support
  ACCESS-KEYS and TABINDEX for widgets that are not hidden?

- Support general client-side scripting hooks (core events and input events)?
  Also, can we somehow integrate button input fields for client-side scripting?

- Support images for submit buttons.

- Implement a ``ButtonForm`` class that will render a form with a single submit
  button, just to redirect somewhere, no table.  General purpose buttons that
  would be a form in themselves... we need to provide some mechanism for easily
  rendering those rather than to have to define an empty form.

- Implement 'noempty' in the renderers (previous code: it isn't used much apart
  from the profile and cannot be guaranteed to make sense anymore.  We are
  better work around it in the client code.)

  This is actually not quite right: in the display renderer, it does make sense
  to not want to render fields for which there is no value set.  It only makes
  sense for the display-only renderer.  Maybe that renderer could take an option
  in its constructor?

- For the parser: Maybe we could eventually provide a way to at least decode the
  args which have no corresponding field in the form (if that never becomes
  necessary, don't do so).

- For Menus: 

  * Support disabled state for single options.
  * Support option groups and associated disabled state.



More Tests
==========

- Automate tests for four cases: hidden, valid, invalid, empty.

