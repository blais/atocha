================
  atocha: TODO
================

- Convert all my codebase to Atocha.


- Auto generate documentation for all the fields using their docstrings and a
  simple script.




- Implement a menu that redirects on change based on this:
  http://cscie12.dce.harvard.edu/lecture_notes/20050316/slide50.html

  Using that, implement a change of renderer.

- Look at widgets from FormEncode and see if some of them can be adapted to my
  framework.


- Create a mod_python normalizer, and one for draco (my framework).

- Provide examples for:

  * Parsing with user checks
  * Customized rendering

  Examples should also be runnable code, use the same files (maybe with symlinks
  to remove the extensions).





Ideas and Eventually
====================

- Document the types_* where a list is present.  Type assertions should use a
  debugging function that can be noop'ed and that recurses into the lists for
  better type checking and that can be noop'ed for efficiency.  Find a way to do
  that.

- Could our system support fields which have more than one varname?  I think so.
  Would that be useful?  If it does, look into doing this, creating fields which
  are comprised of multiple possibly-heterogeneous input widgets.  For example,
  we could have a date field with three string input widgets.  Implement a date
  field with three input widgets to test the varname list with more than one
  name.

- Consider making the implementation for the form renderer use a delegate rather
  than derivation.  The delegate would be specified as a class attribute on the
  form renderer itself.  This reflects well the fact that the form renderer
  changes, but the styling code contains no if little variable code.

  I'm not sure about this, since the text form renderer already does take an
  option...

- Implement DISABLED and READ-ONLY options for all the fields.

  * Hmmm... a field can be visible/enabled, visible/disabled or hidden.  It
    cannot be hidden/disabled.

  * Also, a field can be rendered disabled, but not actually be disabled
    permanently.  I'm not sure what would be the utility in creating a field as
    disabled.  Disabled is akin to hidden, and as such is more of a rendering
    option than anything else.  IMO we should support disabled similar to
    hidden.

- Support ACCESS-KEYS and TABINDEX for widgets that are not hidden?

- Support general client-side scripting hooks (core events and input events)?
  Can we integrate button input fields for client-side scripting?

- Support images for submit buttons.

- Create builder.cgi builder test script, where you gradually store the form
  contents in the session data, where you can create fields and remove them too.
  Also, simple test with a menu and a list of widget strings to eval would be
  nice and easy.

- Implement a ``ButtonForm`` class that will render a form with a single submit
  button, just to redirect somewhere, no table.


- Implement 'noempty' in the renderers (previous code: it isn't used much apart
  from the profile and cannot be guaranteed to make sense anymore.  We are
  better work around it in the client code.)
  
  This is actually not quite right: in the display renderer, it does make sense
  to not want to render fields for which there is no value set.  It only makes
  sense for the display-only renderer.  Maybe that renderer could take an option
  in its constructor?




New Widgets
-----------

- Other widgets:

   - Reset button, see Quixote for some examples.
   - General purpose buttons that would replace the submit one anywhere...?

- Something to fix eventually: the JSDateField script has hardcoded paths for
  its accompanying images... not sure what to do about this yet. I suppose the
  user has to copy the files anyway, so it might be ok to assume he might edit
  the scripts somewhat.

Parser
------

- Maybe we could eventually provide a way to at least decode the args which
  have no corresponding field in the form (if that never becomes necessary,
  don't do so).


Tests
=====

- Automate tests for four cases: hidden, valid, invalid, empty.
- Automate tests using branch coverage.









Changes to adapt existing hume code with
----------------------------------------

default=  becomes  initial=
notnull=  becomes  required=

Field.prepare_value becomes render_value
Field.parse becomes Field.parse_value
Form.addField becomes Field.addfield

Remove method calls on former FormError class:
    def formerrors( self ):
    def errlabels( self ):
    def errnames( self ):
    def errfields( self ):

- Orientation for radio fields has become an int, change from 'minitable'.

ActiveDateField become JSDateField

ListField becomes CheckboxesField

hidden fields now require an explicit 'hidden=1' option.

form_parser: Needs a concrete implementation for hume:

# change this to use the errors to check if there are errors
        if self._status:
            if not self._messages:
                setStatus(self._status, self.__generic_message)
            else:
                setStatus(self._status, '  '.join(self._messages))

            if len(self):
                setFormData(self._form.name, self)
            if self._errors:
                setFormErrors(self._form.name, self._errors)

