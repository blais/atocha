================
  atocha: TODO
================

Current Affairs (Requirements Before 1.0 Final Release)
=======================================================

- Write more complete usage documentation for Atocha, in LaTeX using the
  standard Python tools.

- Maybe we should make StringField use a default encoding of latin-1 and create
  a UnicodeField for strings with default encoding 'unicode'.

- Add a section in document about dealing with multiple submit buttons and an
  example.

- Add a section in document about extending with new fields and how to register
  new rendering methods for each renderer from outside the library (Note: right
  now the only way would be to derived form the renderer class, which is
  obviously not acceptable--at least not in Python.  We need to implement a
  double-dispatch mechanism).

  WE NEED TO HAVE A DOUPLE-DISPATCH MECHANISM FOR EXTENDING NICELY WITH CUSTOM
  RENDERING BEFORE WE RELEASE THIS.




Known Bugs and Misfeatures
==========================

Double-Dispatch Mechanism
-------------------------

- You need to think more about the double-dispatch mechanism for extending the
  renderer or creating new fields, in particular:

  - Derived field classes should either be handled automatically, or there
    should be a way for them to decide which method is to be used for rendering;

  - Renderers could choose not to implement certain methods, instead letting the
    inheritance decide which method is invoked.

  We could use a multimethods package to implement this more cleanly, because
  right now derivation from the renderer classes is required, and that's just
  not nice enough.  Extending the system with a new field, it should be possible
  to provide not only the field but to register custom rendering methods that
  depend both on the renderer class and obviously to be dispatched from the type
  of the new field.


Other
-----

- There is a circular dependency between the parser and its accessor object and
  this causes the GC to be invoked.

- Sometimes we want to getvalue() and getsubmit() from a completed parser, but
  when using the static method we get the accessor object.  This has one
  advantage: when using the static method we return the accessor object only and
  thus we make sure that the parser cannot be used anymore.  We could consider
  return the parser only and making the accessor object only work when accessed
  from the parser as parser.o.<fieldname>. This way we could avoid the circular
  dependency and always returning the parser (even from the static method) would
  yield a more regular interface. Plus I think that there are some cases where
  the methods on the accessor are not sufficient, even when the parser is
  complete.

- The JSDateField does not yet support disabled/read-only states.  We would need
  to change the JavaScript file to support that.

- You need to customize the javascript file when you copy them, to adjust some
  of the paths at the top of the file to point to the appropriate icons that it
  refers.

- We do support accessibility features yet (but we could and we will). See notes
  below.

- We need to support more of the JS tags. - onclick - onchange, etc.  I need
  more time to test them, for now I just put the ones that I needed immediately
  (checkboxes, menus).

- The tests don't run in optimized mode, this is not really a bug, but rather
  just to the assert function that we use in the test.

- It would be nice to be able to give a special CSS class to a buttons array
  form, in case we want to specialize its style.  Also, we might want to render
  the buttons array with the INPUT type 'button' rather than 'submit'.

- We could share the values and submit value between the FormParser and
  ParserAccessor using a weakref form the accessor to the parser rather than the
  kludgy approach we're using now.


Future New Field Types Ideas
============================

- Complete the SetFileField with some JavaScript to hide the file input field
  when the reset button is checked.

- Implement a CaptchaField which generates a captcha image automatically.

- Maybe derive from FileUpload and implement a Photograph field that reads the
  value entirely and can print it and display it.  That field could also have
  some Javascript to reset that field automatically.

- Implement a BoolField that requires being checked (AgreeField).

- Grab some of the fields from other libraries and adapt.  Also look at widgets
  from FormEncode and see if some of them can be adapted to my framework.

- Implement a menu that redirects on change based on this:
  http://cscie12.dce.harvard.edu/lecture_notes/20050316/slide50.html

- Something to fix eventually: the JSDateField script has hardcoded paths for
  its accompanying images... not sure what to do about this yet. I suppose the
  user has to copy the files anyway, so it might be ok to assume he might edit
  the scripts somewhat.


Ideas
=====

- Write a simple example of templating library integration, something simple
  that everyone can understand, just replacing div tags with ids by regexps or
  something.

- Document the types_* subtypes where a list is present.  Type assertions should
  use a debugging function that can be noop'ed and that otherwise recurses into
  the lists for better type checking and that can be noop'ed for efficiency.
  Find a way to do that.

- Consider making the implementation for the form renderer use a delegate rather
  than derivation.  The delegate would be specified as a class attribute on the
  form renderer itself.  This reflects well the fact that the form renderer
  changes, but the styling code contains no if little variable code.

  I'm not sure about this, since the text form renderer already does take an
  option...

- Support accessibilityL FIELDSET, LEGEND, LABEL tags for organization.  Deal
  with Access keys, tab index.  This should be a simple matter of supporting
  adding attributes and then making the renderers support them.  Support
  ACCESS-KEYS and TABINDEX for widgets that are not hidden?

- Support general client-side scripting hooks (core events and input events)?
  Also, can we somehow integrate button input fields for client-side scripting?

- Support images for submit buttons.

- Implement a ``ButtonForm`` class that will render a form with a single submit
  button, just to redirect somewhere, no table.  General purpose buttons that
  would be a form in themselves... we need to provide some mechanism for easily
  rendering those rather than to have to define an empty form.

- Implement 'noempty' in the renderers (previous code: it isn't used much apart
  from the profile and cannot be guaranteed to make sense anymore.  We are
  better work around it in the client code.)

  This is actually not quite right: in the display renderer, it does make sense
  to not want to render fields for which there is no value set.  It only makes
  sense for the display-only renderer.  Maybe that renderer could take an option
  in its constructor?

- For the parser: Maybe we could eventually provide a way to at least decode the
  args which have no corresponding field in the form (if that never becomes
  necessary, don't do so).

- For Menus: 

  * Support disabled state for single options.
  * Support option groups and associated disabled state.



More Tests
==========

- Automate tests for four cases: hidden, valid, invalid, empty.

