#!/usr/bin/env python
#
# $Id$
#

"""
Script that automatically generates documentation for all the fields using the
docstrings of each field in restructuredtext.
"""

# stdlib imports.
import types, textwrap, datetime, StringIO, tempfile
from subprocess import call

# atocha imports.
import atocha
import atocha.fields

#-------------------------------------------------------------------------------
#
template = """
========================
  Atocha Field Classes
========================

:Abstract:

   Description of all the field classes provided with Atocha.
   This file is automatically generated from the docstrings of the fields.
   You can also try most or all of these fields at the online demo.

.. contents::
.. section-numbering::

"""

_opts_as_table = 0

#-------------------------------------------------------------------------------
#
def main():
    import optparse
    parser = optparse.OptionParser(__doc__.strip())
    opts, args = parser.parse_args()

    o = StringIO.StringIO()

    # Print prelude.
    print >> o, template  ## % {'date': datetime.date.today()}

    # For all modules...
    mods = {}
    for mod in atocha.fields.__dict__.itervalues():
        if not (type(mod) is types.ModuleType and
                mod.__name__.startswith('atocha.fields')):
            continue

        # Get the first line of the module.
        moddesc = mod.__doc__.strip().splitlines()[0]
        print >> o
        print >> o,  moddesc
        print >> o,  '=' * len(moddesc)
        print >> o

        # Find the public field classes in the module.
        fclasses = []
        for xname in mod.__all__:
            x = getattr(mod, xname)
            if (type(x) is types.ClassType and
                issubclass(x, atocha.Field) and
                not x.__name__.startswith('_')):
                fclasses.append(x)
        fclasses.sort(lambda x, y: cmp(str(x), str(y)))

        # Generate the documentation for each of the classes.
        for cls in fclasses:
            print >> o,  cls.__name__
            print >> o,  '-' * len(cls.__name__)
            print >> o
            print >> o,  textwrap.dedent(cls.__doc__)

            aset, adescs = cls.get_attributes()
            if _opts_as_table:
                print >> o
                print >> o, '.. csv-table::'
                print >> o, '   :class: field-options'
                print >> o, '   :widths: 5, 5, 50'
                print >> o, '   :header: "Name", "Type", "Description"'
                print >> o, '   :delim: {'
                print >> o
                for aname, atype, adesc, amand in adescs:
                    print >> o, '  ', '{'.join(
                        (aname, atype, ' '.join(adesc.splitlines())) )
                print >> o
            else:
                print >> o, '.. topic:: Valid Attributes'
                print >> o, '   :class: field-options'
                print >> o
                for aname, atype, adesc, amand in adescs:
                    if not amand:
                        atype += ' (Optional)'
                    print >> o, '    %s  --> %s' % (aname, atype)
                    print >> o, '       ', ' '.join(adesc.splitlines())
                print >> o

    f = tempfile.NamedTemporaryFile()
    f.write(o.getvalue())
    f.flush()

    call(['projects-rst2html', '--project-header', '--project-home=..',
          f.name, 'fields.html'])

if __name__ == '__main__':
    main()



