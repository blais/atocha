<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>atocha: 10-min Tutorial</title>
<link rel="stylesheet" href="../style.css" type="text/css" />
</head>
<body>

<div id="project-header">
  <a href="/"><img src="/home/furius-logo-w.png" id="logo"></a>
  <div id="project-home"><a href="..">Project Home</a></div>
</div>

<div class="document" id="atocha-10-min-tutorial">
<h1 class="title">atocha: 10-min Tutorial</h1>
<div class="abstract topic">
<p class="topic-title first">Abstract</p>
<p>A short and sweet overview and tutorial to teach the flavour of what the
Atocha library provides for the web developer.</p>
</div>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#introduction" id="id2" name="id2">Introduction</a></li>
<li><a class="reference" href="#form-definition" id="id3" name="id3">Form Definition</a></li>
<li><a class="reference" href="#form-rendering" id="id4" name="id4">Form Rendering</a><ul>
<li><a class="reference" href="#breaking-down-the-rendering" id="id5" name="id5">Breaking down the Rendering</a></li>
<li><a class="reference" href="#dynamically-generated-choices" id="id6" name="id6">Dynamically Generated Choices</a></li>
</ul>
</li>
<li><a class="reference" href="#form-handling" id="id7" name="id7">Form Handling</a></li>
<li><a class="reference" href="#display-renderers" id="id8" name="id8">Display Renderers</a></li>
<li><a class="reference" href="#options" id="id9" name="id9">Options</a></li>
<li><a class="reference" href="#online-demo" id="id10" name="id10">Online Demo</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="introduction" name="introduction">Introduction</a></h1>
<p>This document presents a quick overview and tutorial about the Atocha web form
rendering and handling library.  This is meant to quickly provide a sense of
what the library does.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="form-definition" name="form-definition">Form Definition</a></h1>
<p>You create a single <tt class="docutils literal"><span class="pre">Form</span></tt> instance for both rendering and handling of the
form.  The form consists of &quot;fields&quot;, which are akin to desktop application
widgets, which automatically return an appropriate data type for the value
entered by the user:</p>
<pre class="literal-block">
myform = Form(
    'person-form',

    # Normal unicode string.
    StringField('firstname', N_(&quot;First name&quot;)),
    StringField('lastname', N_(&quot;Last name&quot;)),

    # Email address and URL fields.
    EmailField('email', N_(&quot;Email&quot;)),

    # Simple date.
    DateField('birthday', N_(&quot;Birthday&quot;)),

    # Radio buttons.
    RadioField('sex', [('m', N_('Male')),
                       ('f', N_('Female')),
                       ('x', N_('Maybe'))],
               N_('Gender'), orient=ORI_HORIZONTAL,
               initial='x'),

    action='/person/handler')
</pre>
<p>This form can be created at global module level, and does not have to be
recreated on every request.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="form-rendering" name="form-rendering">Form Rendering</a></h1>
<p>You can then use this form object, in collboration with a <tt class="docutils literal"><span class="pre">FormRenderer</span></tt> to
render the form on a page for the user to fill in:</p>
<pre class="literal-block">
# In resource: /person/edit...

rdr = TextFormRenderer(myform, values, errors)

# Print some HTML
#...

# Render the form.
sys.stdout.write( rdr.render(action='handle.cgi') ) 

# Complete the page rendering.
# ...   
</pre>
<p>Note that a set of initial values and errors is specified for the renderer to
use, and usually will come from session data to provide error feedback if the
form is being re-rendered for errors from user input.</p>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="breaking-down-the-rendering" name="breaking-down-the-rendering">Breaking down the Rendering</a></h2>
<p>One problem with automatic rendering of form is that it breaks down quite
rapidly as soon as you want to render fancy forms, which always end up requiring
Hand-customization.  The basic automatic rendering provides a reasonably good
looking table, for more commercial-grade websites, you will certainly want to do
some hand design.</p>
<p>For this purpose, the renderer interface contains a lower-level interface that
allows you to render form components individually.  The rendering can be heavily
customized this way by breaking down the process in its component phases, which
lets you decide on the particular layout of the widgets by embedding the inputs
wherever you want within your system:</p>
<pre class="literal-block">
rdr = TextFormRenderer(myform, values, errors,
                     output_encoding='latin-1')
      
print rdr.render_container(action='/edit/handler2')
      
print &quot;&lt;div id=&quot;email&quot;&gt;
print &quot;&lt;p&gt;Your email, please:&lt;/p&gt;
print rdr.render_field('email')     # Render just the email field.
print &quot;&lt;/div&gt;
</pre>
<p>You could easily use this system to embed Atocha in your favourite templating
system.  Atocha does not bind to a templating system and is entirely orthogonal
to any web application framework.</p>
<p>You could create some kind of syntax in HTML for your templating system for
specifying that a field's inputs should be rendered in-place, e.g.:</p>
<pre class="literal-block">
&lt;div&gt;
   Too much fun? &lt;div id=&quot;atocha:fun&quot; /&gt;
...
</pre>
<p>The form rendering code is completely decoupled from the form definition, so it
becomes possible to create custom form renderers for your particular system or
with specific layout characteristics, without changing the library (more below).
For example, two form renderers are provided with the library: a renderer that
outputs unicode text, and a renderer that builds a tree of nodes using my
htmlout library.  You could easily implemnent one using Stan (from Nevow) if you
liked.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="dynamically-generated-choices" name="dynamically-generated-choices">Dynamically Generated Choices</a></h2>
<p>If you need to render menus, listboxes, radio buttons, checkbox lists that are
generated dynamically, you can simply set the list of valid choices on the field
before rendering or parsing, in the renderer:</p>
<pre class="literal-block">
form['matches'].setchoices(found_matches)
...
rdr.render_field('matches')
...
</pre>
<p>And in the parser (only needed if the choice field has &quot;choice checking&quot;
enabled):</p>
<pre class="literal-block">
form['matches'].setchoices(found_matches)
...
p = FormParser(f, args)
rdr.render_field('matches')
...
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="form-handling" name="form-handling">Form Handling</a></h1>
<p>A <tt class="docutils literal"><span class="pre">FormParser</span></tt> instance is used to oversee the process of parsing and
validating user-submitted inputs.  The basic validation of the data types output
from the fields is automatic, and the particular types depend on the types of
the fields in the form.</p>
<p>Most often the validation can only be implemented on the client-side.  There is
always custom code that needs be setup there to verify the constraints of the
widgets or between widgets.  Rather than forcing you to implement custom
validator classes for every handler page, the parser allows you to invoke
methods to signal errors and to indicate completion of the parsing, so you can
validate in any order that is most convenient:</p>
<pre class="literal-block">
# In resource, e.g. /person/handle that gets called from a form...
# The resource receives the arguments 'args'.
parser = FormParser(myform, args, '/person/edit')

if p['sex'] == 'x':
    p.error(u'Please fix error in gender below.',
            dances=(u'What do you mean, maybe?', 'm'))

# ... more validation code...

# Indicate the end of parsing.  Redirection may occur here if there
# are errors.
p.end()

# Set final data in database and remove session data.
#...
</pre>
<p>This pattern establishes a protocol in which you can customize validation
(another pattern involves attaching validators to the widgets, but we think it
is more limited and complicated than the simple protocol that we offer)</p>
<p>When the parsing is complete, the parser either redirects automatically to the
submitter resource if necessary, with the accumulated errors for rendering the
annotated form back to the user, or contains the final parsed values for client
perusal.  At this point you can use the data to store it or do whatever else you
want with it.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="display-renderers" name="display-renderers">Display Renderers</a></h1>
<p>The form object can also be used to display parsed values in a nice-looking
table, without editing capabilities.  This is simply accomplished by using a
special kind of renderer, that I call &quot;display renderers&quot;, and which instead of
rendering inputs outputs a table with rendered values.</p>
<p>This is useful because much information about presentation of a form's data is
already present in the form definition:</p>
<pre class="literal-block">
# Create display renderer to display the data.
rdr = TextDisplayRenderer(myform, values)
      
print &quot;&lt;div id=&quot;person&quot;&gt;
print &quot;&lt;p&gt;Person Profile:&lt;/p&gt;
print rdr.render()  # Renders a table.
print &quot;&lt;/div&gt;
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="options" name="options">Options</a></h1>
<p>The <tt class="docutils literal"><span class="pre">Form</span></tt>, <tt class="docutils literal"><span class="pre">FormRenderer</span></tt> and <tt class="docutils literal"><span class="pre">FormParser</span></tt> and <tt class="docutils literal"><span class="pre">Field</span></tt> classes support
many options for various parameters depending on their specific application.
Visit the source code to find out what the specific options are.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id10" id="online-demo" name="online-demo">Online Demo</a></h1>
<p>Try the <a class="reference" href="../test/demo/cgi-bin/display.cgi">online demo</a> which features an instance of most of the fields, to
quickly see what the library can do.</p>
</div>
</div>
</body>
</html>
